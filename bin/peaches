#!/usr/bin/env node

var path = require('path'),
    fs = require('fs'),
    program = require('commander'),
    pkg = require('../package.json'),
    version = pkg.version,
    peaches = require('../lib/peaches'),
    logger = require('nlogger').logger('peaches'),
    cli = require('../lib/cli');

program
    .version(version)
    .option('build', '编译项目')
    .option('deploy', '编译并发布项目,主要用于自动上传图片到线上服务器')
    .option('-p, --pkg <package.json>', '设置package.json的路径,默认使用当前目录下的package.json')
    .option('--encoding <encoding>', '指定在进行文件处理时，涉及到的文件编码。 默认是 utf8 ')
    .option('-r, --autoReload', '设置是否根据文件的变更自动编译。默认为 false')
    .parse(process.argv);

if (!program.pkg) {
    program.pkg = './package.json';
}
if (!program.src) {
    program.src = './src';
}
if (!program.encoding) {
    program.encoding = 'utf-8';
}
if (!program.hasOwnProperty('autoReload')) {
    program.autoReload = false;
}

/**
 * 读取打包配置
 * 读取package.json文件,位于脚本执行的目录下.
 * 关于package.json的详细说明: docs/package.json.md;
 * @return {Object} package
 */
function loadConfig() {
    "use strict";
    //如果没有输入pkg配置的路径,那么查找当前路径中是否又package.json
    var config;
    try {
        config = fs.readFileSync(program.pkg);
    } catch (e) {
        logger.error('无法读取package.json，系统退出！');
        process.exit(1);
    }
    try {
        config = JSON.parse(config);
    } catch (ex) {
        logger.error('package.json 定义似乎有问题,检查一下!');
        process.exit(1);
    }
    var servers = config.server,
        baseDir = path.dirname(program.pkg),
        o, dist;

    if (program.build) {
        config.server = servers.build;
    }
    else if (program.deploy) {
        config.server = servers.deploy;
    }
// 如果没有输入 build 和 deploy 那么使用 build方式处理。
    else {
        config.server = servers.build;
    }
// 转化为绝对路径 开始..
    config.server.root = path.join(baseDir, config.server.root + '/');
    config.server.tmp = path.join(baseDir, config.server.tmp + '/');
    if (!fs.existsSync(config.server.root)) {
        try {
            fs.mkdirSync(config.server.root);
        }
        catch (e) {
            logger.error('无法创建目录：{}', config.server.root);
            process.exit(1);
        }
    }
    if (!fs.existsSync(config.server.tmp)) {
        try {
            fs.mkdirSync(config.server.tmp);
        }
        catch (e) {
            logger.error('无法创建目录：{}', config.server.tmp);
            process.exit(1);
        }
    }

    var output2 = {};
    for (o in config.output) {
        if (config.output.hasOwnProperty(o)) {
            dist = path.join(baseDir, o);
            output2[dist] = [];
            config.output[o].forEach(function (src) {
                output2[dist].push(path.join(baseDir, src));
            });
        }
    }
    config.output = output2;
    // 转化为绝对路径 结束..
    return config;
}

var config = loadConfig(),
    watchFileList = [];
// 当CSS文件变更是，自动编译 开始。。。
function watchFile(curr, prev) {
    if (curr.mtime.getTime() !== prev.mtime.getTime()) {
        cli.main(config);
    }
}
function watchOutput() {
    for (var o in config.output) {
        if (config.output.hasOwnProperty(o)) {
            config.output[o].forEach(function (cssFile) {
                watchFileList.push(cssFile);
                fs.watchFile(cssFile, watchFile);
            });
        }
    }
}

if (program.autoReload) {
    watchOutput();

    fs.watchFile(program.pkg, function (curr, prev) {
        if (curr.mtime.getTime() !== prev.mtime.getTime()) {
            config = loadConfig();
            cli.main(config);
            
            watchFileList.forEach(function (file) {
                fs.unwatchFile(file, watchFile);
            });
            watchFileList = [];
            watchOutput();
        }
    });
}
// 当CSS文件变更是，自动编译 结束。。。


cli.main(config);
